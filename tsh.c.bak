/*
 * Enhanced tiny shell (tsh)
 * Features added to make this project resume-ready:
 * - Proper tokenization supporting single and double quotes
 * - Multiple pipes (cmd1 | cmd2 | cmd3 ...)
 * - Input (<), output (>, >> append) redirection
 * - Background execution with '&'
 * - In-memory history and `history` builtin
 * - Job management: background jobs, `jobs`, `fg` builtins
 * - Builtins: cd, pwd, exit, help, history, jobs, fg
 * - Basic SIGCHLD handler to reap background children
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <ctype.h>

#define MAX_ARGS 128
#define MAX_LINE 8192
#define MAX_CMDS 32
#define HISTORY_SIZE 200
#define MAX_JOBS 128

typedef struct command {
    char *argv[MAX_ARGS];
    char *infile;
    char *outfile;
    int append; // outfile append (>>)
} command_t;

typedef struct job {
    pid_t pgid;
    int jid;
    char *cmdline;
    int running; // 1 running, 0 done
} job_t;

static char *history[HISTORY_SIZE];
static int history_len = 0;

static job_t jobs[MAX_JOBS];
static int next_jid = 1;

static void add_history(const char *line) {
    if (!line || *line == '\0') return;
    if (history_len == HISTORY_SIZE) {
        free(history[0]);
        memmove(history, history+1, sizeof(char*)*(HISTORY_SIZE-1));
        history_len--;
    }
    history[history_len++] = strdup(line);
}

static void print_help(void) {
    printf("tsh - Tiny enhanced shell\n");
    printf("Built-in commands:\n");
    printf("  cd [dir]      - change directory (HOME if omitted)\n");
    printf("  pwd           - print working directory\n");
    printf("  exit          - exit shell\n");
    printf("  help          - show this help\n");
    printf("  history       - show command history\n");
    printf("  jobs          - list background jobs\n");
    printf("  fg %%jid       - bring background job to foreground\n");
    printf("Features: quotes, multiple pipes, <, >, >>, background (&)\n");
}

// Job utilities
static int add_job(pid_t pgid, const char *cmdline) {
    for (int i = 0; i < MAX_JOBS; ++i) {
        if (jobs[i].pgid == 0) {
            jobs[i].pgid = pgid;
            jobs[i].jid = next_jid++;
            jobs[i].cmdline = strdup(cmdline);
            jobs[i].running = 1;
            return jobs[i].jid;
        }
    }
    return -1;
}

static job_t* find_job_by_jid(int jid) {
    for (int i = 0; i < MAX_JOBS; ++i) if (jobs[i].pgid != 0 && jobs[i].jid == jid) return &jobs[i];
    return NULL;
}

static job_t* find_job_by_pgid(pid_t pgid) {
    for (int i = 0; i < MAX_JOBS; ++i) if (jobs[i].pgid == pgid) return &jobs[i];
    return NULL;
}

static void remove_job(job_t *j) {
    if (!j) return;
    free(j->cmdline);
    j->cmdline = NULL;
    j->pgid = 0;
    j->jid = 0;
    j->running = 0;
}

static void print_jobs(void) {
    for (int i = 0; i < MAX_JOBS; ++i) {
        if (jobs[i].pgid != 0) {
            printf("[%d] %s   %s\n", jobs[i].jid, jobs[i].running ? "Running" : "Done", jobs[i].cmdline);
        }
    }
}

// SIGCHLD handler: reap children and mark jobs as done
static void sigchld_handler(int sig) {
    (void)sig;
    int saved_errno = errno;
    pid_t pid;
    int status;
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        // find job by pgid or pid
        job_t *j = find_job_by_pgid(pid);
        if (!j) {
            // maybe child is part of a pgid; search by matching pgid
            for (int i = 0; i < MAX_JOBS; ++i) {
                if (jobs[i].pgid != 0) {
                    // check if any child of this pgid has exited - best-effort
                    if (kill(-jobs[i].pgid, 0) == -1 && errno == ESRCH) {
                        // process group doesn't exist => job finished
                        j = &jobs[i];
                        break;
                    }
                }
            }
        }
        if (j) {
            j->running = 0;
            // notify user
            char buf[512];
            int n = snprintf(buf, sizeof(buf), "\n[%d] Done   %s\n", j->jid, j->cmdline);
            if (n > 0) write(STDOUT_FILENO, buf, n);
        }
    }
    errno = saved_errno;
}

// Basic tokenizer that understands single and double quotes and special tokens
static char *next_token(char **s) {
    char *p = *s;
    if (!p) return NULL;
    while (isspace((unsigned char)*p)) p++;
    if (*p == '\0') { *s = NULL; return NULL; }

    char *start = p;
    if (*p == '"' || *p == '\'') {
        char quote = *p++;
        start = p;
        while (*p && *p != quote) {
            if (*p == '\\' && p[1]) p += 2; else p++;
        }
        if (*p == quote) {
            *p = '\0';
            p++;
        }
        *s = p;
        return start;
    }

    // check for multi-char operators >>
    if (p[0] == '>' && p[1] == '>') {
        *s = p + 2;
        return ">>";
    }
    // single-char special tokens
    if (*p == '<' || *p == '>' || *p == '|' || *p == '&') {
        static char op[2];
        op[0] = *p;
        op[1] = '\0';
        *s = p + 1;
        return op;
    }

    // normal token
    start = p;
    while (*p && !isspace((unsigned char)*p) && *p != '<' && *p != '>' && *p != '|' && *p != '&') p++;
    if (*p) {
        *p = '\0';
        *s = p + 1;
    } else {
        *s = NULL;
    }
    return start;
}

// Parse line into commands
static int parse_line(char *line, command_t cmds[], int *background) {
    char *p = line;
    int cmd_idx = 0;
    int arg_idx = 0;
    cmds[0].infile = cmds[0].outfile = NULL; cmds[0].append = 0;
    for (int i=0;i<MAX_CMDS;i++) for (int j=0;j<MAX_ARGS;j++) cmds[i].argv[j]=NULL;

    *background = 0;
    char *tok;
    while ((tok = next_token(&p))) {
        if (strcmp(tok, "|") == 0) {
            // next command
            cmd_idx++;
            if (cmd_idx >= MAX_CMDS) { fprintf(stderr, "tsh: too many piped commands\n"); return -1; }
            arg_idx = 0;
            cmds[cmd_idx].infile = cmds[cmd_idx].outfile = NULL; cmds[cmd_idx].append = 0;
            continue;
        }
        if (strcmp(tok, "<") == 0) {
            char *file = next_token(&p);
            if (!file) { fprintf(stderr, "tsh: syntax error: expected filename after '<'\n"); return -1; }
            cmds[cmd_idx].infile = file;
            continue;
        }
        if (strcmp(tok, ">") == 0 || strcmp(tok, ">>") == 0) {
            int append = (strcmp(tok, ">>") == 0);
            char *file = next_token(&p);
            if (!file) { fprintf(stderr, "tsh: syntax error: expected filename after '>'\n"); return -1; }
            cmds[cmd_idx].outfile = file;
            cmds[cmd_idx].append = append;
            continue;
        }
        if (strcmp(tok, "&") == 0) {
            // background indicator; must be at end
            *background = 1;
            // free tok if allocated by next_token
            continue;
        }
        // normal argument
        cmds[cmd_idx].argv[arg_idx++] = tok;
        if (arg_idx >= MAX_ARGS-1) { fprintf(stderr, "tsh: too many args\n"); return -1; }
    }
    // count commands = cmd_idx+1
    return cmd_idx+1;
}

// no-op: tokens point into original buffer and are freed with the original line

static int is_builtin(command_t *c) {
    if (!c->argv[0]) return 0;
    const char *b[] = {"cd","pwd","exit","help","history","jobs","fg", NULL};
    for (int i=0;b[i];i++) if (strcmp(c->argv[0], b[i])==0) return 1;
    return 0;
}

static int handle_builtin(command_t *c) {
    if (!c->argv[0]) return 0;
    if (strcmp(c->argv[0], "exit") == 0) exit(0);
    if (strcmp(c->argv[0], "cd") == 0) {
        const char *dir = c->argv[1] ? c->argv[1] : getenv("HOME");
        if (!dir || chdir(dir) != 0) perror("tsh: cd");
        return 1;
    }
    if (strcmp(c->argv[0], "pwd") == 0) {
        char cwd[4096]; if (getcwd(cwd, sizeof(cwd))) printf("%s\n", cwd);
        return 1;
    }
    if (strcmp(c->argv[0], "help") == 0) { print_help(); return 1; }
    if (strcmp(c->argv[0], "history") == 0) {
        for (int i=0;i<history_len;i++) printf("%4d  %s", i+1, history[i]);
        return 1;
    }
    if (strcmp(c->argv[0], "jobs") == 0) { print_jobs(); return 1; }
    if (strcmp(c->argv[0], "fg") == 0) {
        if (!c->argv[1]) { fprintf(stderr, "tsh: fg: expected %%jid\n"); return 1; }
        int jid = 0;
        if (c->argv[1][0] == '%') jid = atoi(c->argv[1]+1); else jid = atoi(c->argv[1]);
        job_t *j = find_job_by_jid(jid);
        if (!j) { fprintf(stderr, "tsh: fg: job not found\n"); return 1; }
        // wait for pgid
        int status;
        kill(-j->pgid, SIGCONT);
        while (waitpid(-j->pgid, &status, 0) > 0) ;
        remove_job(j);
        return 1;
    }
    return 0;
}

static void execute_pipeline(command_t cmds[], int ncmds, int background, char *origline) {
    int pipes[2*(MAX_CMDS)];
    for (int i=0;i<ncmds-1;i++) if (pipe(pipes + i*2) < 0) { perror("pipe"); return; }

    pid_t pgid = 0;

    for (int i=0;i<ncmds;i++) {
        pid_t pid = fork();
        if (pid < 0) { perror("fork"); return; }
        if (pid == 0) {
            // child
            signal(SIGINT, SIG_DFL);
            signal(SIGCHLD, SIG_DFL);
            // set pgid
            if (pgid == 0) pgid = getpid();
            setpgid(0, pgid);

            // input from previous pipe
            if (i > 0) {
                if (dup2(pipes[(i-1)*2], STDIN_FILENO) < 0) { perror("dup2"); _exit(1); }
            }
            // output to next pipe
            if (i < ncmds-1) {
                if (dup2(pipes[i*2 + 1], STDOUT_FILENO) < 0) { perror("dup2"); _exit(1); }
            }

            // close all pipe fds
            for (int j=0;j<2*(ncmds-1);j++) close(pipes[j]);

            // handle redirection
            if (cmds[i].infile) {
                int fd = open(cmds[i].infile, O_RDONLY);
                if (fd < 0) { perror("tsh: input redir"); _exit(1); }
                dup2(fd, STDIN_FILENO); close(fd);
            }
            if (cmds[i].outfile) {
                int flags = O_WRONLY | O_CREAT | (cmds[i].append ? O_APPEND : O_TRUNC);
                int fd = open(cmds[i].outfile, flags, 0644);
                if (fd < 0) { perror("tsh: output redir"); _exit(1); }
                dup2(fd, STDOUT_FILENO); close(fd);
            }

            execvp(cmds[i].argv[0], cmds[i].argv);
            fprintf(stderr, "tsh: %s: %s\n", cmds[i].argv[0], strerror(errno));
            _exit(127);
        }
        // parent
        if (pgid == 0) pgid = pid;
    setpgid(pid, pgid);
    }

    // close pipes in parent
    for (int j=0;j<2*(ncmds-1);j++) close(pipes[j]);

    if (background) {
        int jid = add_job(pgid, origline);
        if (jid < 0) fprintf(stderr, "tsh: cannot add job\n");
        else printf("[%d] %d\n", jid, pgid);
        // do not wait
    } else {
        // foreground: wait for process group
        int status;
        while (waitpid(-pgid, &status, 0) > 0) ;
    }
}

void run_command(char *input) {
    // copy input so tokens can be nulled
    char *line = strdup(input);
    if (!line) return;
    // remove trailing newline
    size_t L = strlen(line); if (L>0 && line[L-1]=='\n') line[L-1]='\0';
    if (line[0] == '\0') { free(line); return; }

    add_history(input);

    command_t cmds[MAX_CMDS];
    int background = 0;
    int ncmds = parse_line(line, cmds, &background);
    if (ncmds <= 0) { free(line); return; }

    // Single builtin optimization: if single command and builtin, handle directly
    if (ncmds == 1 && is_builtin(&cmds[0])) {
        handle_builtin(&cmds[0]);
        free(line);
        return;
    }

    execute_pipeline(cmds, ncmds, background, line);

    // don't free tokens (they point into line)
    // but free original line when job registered or not needed
    if (!background) free(line); else { /* jobs keep pointer to strdup'ed line in add_job */ }
}

int main(void) {
    // install SIGCHLD handler
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = sigchld_handler;
    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    sigaction(SIGCHLD, &sa, NULL);

    signal(SIGINT, SIG_IGN);

    char *input = NULL;
    size_t input_size = 0;

    while (1) {
        char cwd[4096]; cwd[0]='\0'; getcwd(cwd, sizeof(cwd));
        printf("tsh:%s> ", cwd[0] ? cwd : "");
        fflush(stdout);
        ssize_t n = getline(&input, &input_size, stdin);
        if (n == -1) {
            if (feof(stdin)) { printf("\n"); break; }
            perror("tsh: getline"); continue;
        }
        run_command(input);
    }

    free(input);
    // free history and jobs
    for (int i=0;i<history_len;i++) free(history[i]);
    for (int i=0;i<MAX_JOBS;i++) if (jobs[i].pgid) free(jobs[i].cmdline);
    return 0;
}